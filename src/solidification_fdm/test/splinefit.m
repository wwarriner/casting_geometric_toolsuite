function [slm,xp,yp] = splinefit( x, y, knots, regularization_parameter, verbosity )
% slmengine: estimates a spline function from data plus a fit prescription
% usage 1: slm = slmengine(x,y);
% usage 2: slm = slmengine(x,y,prescription);
% usage 3: slm = slmengine(x,y,prop1,val1,prop2,val2,...);
% usage 4: slm = slmengine(x,y,prescription,prop1,val1,prop2,val2,...);
% usage 5: [slm,xp,yp] = slmengine(x,y,prescription,prop1,val1,prop2,val2,...);
%
% Note: slmengine is the command driven tool for fitting a model
%   to data. It uses either a prescription structure (as supplied by
%   slmset) or sets of property/value pairs. Those pairs are defined
%   in the help to slmset. slmengine is also used by slmfit, the gui
%   tool for fitting a curve to data.
%
% Note: The optimization toolbox (lsqlin) is generally required for
% most fits. Some models (those where the break points are also
% estimated) require fmincon.
%
% Note: Some prescriptive parameters or combinations will be
%   inappropriate for the lower degree models.
%
% arguments: (input)
%  x,y     - vectors of data used to fit the model. Any
%            NaN or inf elements (in x or y) will be excluded
%            from the fit.
%
%  prescription - structure generated by slmset to control the
%            fitting process.
%
%            Alternatively, one can simply supply property/value
%            pairs directly to slmengine.
%
% Arguments: (output)
%  slm     - model as a shape-language-model structure,
%            normally constructed by slmfit or slmengine. slm
%            may also be returned in other forms, either a pp
%            structure tht ppval can use, or as a simple array
%            of coefficients.
%
%            Upon return, slm will contain a structure field 'stats'
%            that holds fields which describe the quality of fit:
%
%            slm.stats.TotalDoF = Total degrees of freedom in the model
%
%            slm.stats.NetDoF = Net degrees of freedom in the spline model.
%               Thus, NetDoF reflects any equality constraints in the model
%
%            slm.stats.R2 = Traditional R-squared coefficient
%
%            slm.stats.R2Adj = Adjusted R^2, accounting for changing
%               degrees of freedom. For a definition, look here:
%
%               http://en.wikipedia.org/wiki/Coefficient_of_determination
%
%            slm.stats.RMSE = Root-Mean-Squared-Error
%
%            slm.stats.ErrorRange = 1x2 vector that contains the minimmum
%               and maximum errors, defined as (Yhat - Y)
%
%            slm.stats.Quartiles = 1x2 vector that contains the 25% and 75%
%               error quartiles. This gives a trimmed measure of the
%               error magnitudes, less any outliers.
%
%  xp, yp  - predicted points along the fitted curve. The number of these
%            points is defined by the predictions property. (see slmset)
%            xp will be a list of equally spaced points.
%
% Example:
%  (See the SLM_tutorial demo for other examples.)
%  x = rand(1,50);
%  y = sin(x*2*pi) + randn(size(x))/10;
%
%  slm = slmengine(x,y,'knots',0:.2:1,'plot','on','concavedown','on','minvalue',0)
%  slm =
%            form: 'slm'
%          degree: 3
%           knots: [6x1 double]
%            coef: [6x2 double]
%    prescription: [1x1 struct]
%               x: [50x1 double]
%               y: [50x1 double]
%
% Returned in a form that ppval or fnval can use:
%
%  slm = slmengine(x,y,'knots',0:.2:1,'plot','on','concavedown','on','minvalue',0,'res','pp')
% slm =
%            form: 'pp'
%          breaks: [0 0.2 0.4 0.6 0.8 1]
%           coefs: [5x4 double]
%          pieces: 5
%           order: 4
%             dim: 1
%    prescription: [1x1 struct]
%
%
% See also: spap2, ppval, fnval
%
% Author: John D'Errico
% e-mail: woodchips@rochester.rr.com
% Release: 1.0
% Release date: 1/2/08

%% NOTES
% x is m x n double array, n is number of splines to be fit, m number of points in each
% spline
% y is m x n double array
% k is p x n double vector of knots
% end_point_values is m x 2 double array, first column is fixed LHS value, last column RHS fixed value
% end_point_slopes is m x 2 double array, same as values, but for derivative
% verbosity is a nonnegative double indicating verbosity level to use

% Output is ...
%  C2 smooth
%  Decreasing (probably)
%  Left slope matches
%  Left value matches
%  Right slope matches
%  Right value matches

%% INPUT CHECKING

knots = unique( knots );
knots = sort( knots );
assert( all( ...
    knots( 1, : ) <= min( x ) ...
    && max( x ) <= knots( end, : ), ...
    "all" ) );

%% SETUP??
nx = size( x, 1 );

%% SCALING
% minimize numerical issues by putting y into range [ 1/phi, phi ]
[ yhat, yscale, yshift ] = scaleproblem( y );

%% FITTING
slm = slmengine_cubic( x, yhat, knots, yscale, regularization_parameter, verbosity );

%% POST PROCESSING
slm.stats.yshift = yshift;
slm.stats.yscale = yscale;
slm.coef(:,1) = (slm.coef(:,1) - yshift)/yscale;
if size(slm.coef,2) > 1
    slm.coef(:,2) = slm.coef(:,2)/yscale;
end

slm.rp = regularization_parameter;
slm.verbosity = verbosity;
slm.knots = knots;
slm.x = x;
slm.y = y;

%% REPORTING
if verbosity > 0
    disp('=========================================')
    disp('MODEL STATISTICS REPORT')
    disp(['Number of data points:      ',num2str(nx)])
    disp(['Scale factor applied to y   ',num2str(yscale)])
    disp(['Shift applied to y          ',num2str(yshift)])
    disp(['Total degrees of freedom:   ',num2str(slm.stats.TotalDoF)])
    disp(['Net degrees of freedom:     ',num2str(slm.stats.NetDoF)])
    disp(['R-squared:                  ',num2str(slm.stats.R2)])
    disp(['Adjusted R-squared:         ',num2str(slm.stats.R2Adj)])
    disp(['RMSE:                       ',num2str(slm.stats.RMSE)])
    disp(['Range of prediction errors: ',num2str(slm.stats.ErrorRange)])
    disp(['Error quartiles (25%, 75%): ',num2str(slm.stats.Quartiles)])
    disp('=========================================')
end

